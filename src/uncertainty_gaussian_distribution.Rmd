---
title: "Simulations of occurrence cubes"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---

```{r setup, include=FALSE}
library(here)
library(knitr)
opts_chunk$set(echo = TRUE,
               warning = FALSE,
               message = FALSE)
opts_knit$set(root.dir = here())

conflicted::conflicts_prefer(dplyr::select())
conflicted::conflicts_prefer(dplyr::filter())

library(sf)
library(tidyverse)
library(ggExtra)
library(mnormt)

options("scipen" = 10)
```

# Data generation

We create a point with 100 m uncertainty.

```{r}
point_df <- tibble(lat = 183900,
                   long = 64000,
                   coordinateUncertaintyInMeters = 100)
```

# Background

There are multiple ways how the uncertainty of `coordinateUncertaintyInMeters` on GBIF could have been generated. This can for example be uncertainty based on the measurement device but also generated by data aggregation for example with sensitive data.

When coordinate uncertainty comes from different sources or the uncertainty generating process is unknown, it might be save to randomly assign a point within a grid cell according to a uniform distribution within its "uncertainty circle". However, if the researcher knows the coordinate uncertainty of all observations relies on the GPS measurements, a normal distribution might be more relevant (see [GPS Uncertainty](https://harbor.academic.wlu.edu/current-courses/geology-100/daily-schedule/campus-mapping-lab/gps-uncertainty/)). Although it must be recognised that this is not strictly a gaussian process [@specht2020].

This could be parametrised when creating the cube. The user decides which distribution (and parameters to use) with recommendations from our side.

-  `uniform(0, coordinateUncertaintyInMeters)`
   -  no modifiable parameters necessary
   -  each location within the uncertainty circle has an equal probability
   -  useful when there are multiple uncertainty generation processes involved or when the process(es) is (are) unknown 
-  `normal(mu = 0, var = -coordinateUncertaintyInMetersÂ² / 2ln(1-p))`
   -  `p` can be chosen by the user, default value is 0.95 (95 % of points fall within circle with radius equal to `coordinateUncertaintyInMeters`)
   -  locations near the center of the uncertainty circle have higher probability then near the edge
   -  there might be multiple reasons for which a normal distribution is more desirable than a uniform distribution that could be argued by the user
      -  e.g. all data come from one project where uncertainty is due to the GPS measuring device

# Visualisation
## Uniform distribution

We visualise a sample of 5000 points. In the uniform case, each random point within the circle of uncertainty has the same probability although the histograms do not seem to look uniform. This is because of the circular shape.

```{r}
set.seed(123)
dat_unif <- tibble(
  random_angle = runif(5000, 0, 2*pi),
  random_r = sqrt(runif(5000, 0, 1)) * 
    point_df$coordinateUncertaintyInMeters
  ) %>%
  mutate(long = point_df$long + random_r * cos(random_angle),
         lat = point_df$lat + random_r * sin(random_angle),
         density = 1)
```

```{r}
scatter_unif <- dat_unif %>%
  ggplot(aes(x = long, y = lat)) + 
    geom_point(colour = "cornflowerblue") +
    geom_segment(data = point_df, 
               aes(x = long, xend = long + coordinateUncertaintyInMeters, 
                   y = lat, yend = lat),
               linewidth = 1.5, colour = "darkgreen") +
    geom_text(aes(y = 183915, x = 64050, label = "100 m"), colour = "black",
              size = 5) +
    geom_point(data = point_df, aes(x = long, y = lat), color = "firebrick") +
    coord_fixed() +
    labs(x = "longitude", y = "latitude") +
    theme(legend.position = "")
    

ggMarginal(scatter_unif, type = "histogram")
```

## Normal distribution

In the normal case, random points closer to the center have a higher probability. 95 % of the random points fall within the bounds of the red circle (`p = 0.95`). The radius of the circle would be equal to the coordinate uncertainty (here `r point_df$coordinateUncertaintyInMeters` m) if we would sample an infinite number of points.

$$
\begin{align}
P(X^2 + Y^2 > 100^2) &= P\left(\left(\frac{X}{\sigma}\right)^2 + \left(\frac{Y}{\sigma}\right)^2 > \frac{100^2}{\sigma^2}\right)\\
  &= P\left(Z_1^2 + Z_2^2 > \frac{100^2}{\sigma^2}\right)\\
  &= \exp(-\frac{100^2}{2\sigma^2})
\end{align}
$$

We set this to $1 - p = 0.05$ such that we can derive the variance $\sigma^2$ (see [Bivariate normal distribution of points](https://math.stackexchange.com/questions/1422374/bivariate-normal-distribution-of-points))

$$
\begin{align}
&\exp(-\frac{100^2}{2\sigma^2}) = 0.05\\
&\Rightarrow \frac{100^2}{2\sigma^2} = - \ln(0.05)\\
&\Rightarrow \sigma^2 = \frac{-100^2}{2\ln(0.05)}
\end{align}
$$

```{r}
npoints <- 100000
```

We test the proportion of random points ($n =$ `r npoints`) outside `r point_df$coordinateUncertaintyInMeters` meters based on this variance.

```{r}
mu <- c(point_df$long, point_df$lat)
p <- 0.95
var <- (-point_df$coordinateUncertaintyInMeters^2) / (2 * log(1 - p))
varcovar <- matrix(c(var, -1, -1, var), nrow = 2)
```

```{r}
nsim <- 100
npoints <- 100000
out_vec <- vector(mode = "list", length = nsim)
for (i in seq_len(nsim)) {
  test_norm <- rmnorm(npoints, mean = mu, varcov = varcovar) %>%
    as_tibble() %>%
    rename(long = V1, lat = V2) %>%
    mutate(density = dmnorm(cbind(long, lat), mean = mu, varcov = varcovar)) %>%
    mutate(dist = sqrt((point_df$long - long)^2 + (point_df$lat - lat)^2))

 out_vec[[i]] <- sum(test_norm$dist > point_df$coordinateUncertaintyInMeters) / 
   npoints
}
sim_df <- do.call(rbind.data.frame, out_vec) %>%
  `colnames<-`("p_val") %>%
  rownames_to_column("n_sim") %>%
  mutate(n_sim = as.numeric(n_sim))

sim_df %>%
  ggplot(aes(x = n_sim, y = p_val, group = 1)) +
    geom_line() +
    geom_point() +
    scale_x_continuous(breaks = seq(0, 100, 10)) +
    scale_y_continuous(limits = c(0.04, 0.06)) +
    geom_hline(yintercept = 0.05, colour = "firebrick") +
    labs(x = paste0("number of simulations (N = ", nsim, ")"),
         y = paste0("proportion of random points (n = ", npoints, ")\noutside ",
                    "circle with radius ", 
                    point_df$coordinateUncertaintyInMeters, " m"))
```

Indeed this looks correct. We visualise a sample of 5000 points.

```{r}
set.seed(123)
dat_norm <- rmnorm(5000, mean = mu, varcov = varcovar) %>%
  as_tibble() %>%
  rename(long = V1, lat = V2) %>%
  mutate(density = dmnorm(cbind(long, lat), mean = mu, varcov = varcovar))

scatter_norm <- dat_norm %>%
  ggplot(aes(x = long, y = lat)) + 
    geom_point(aes(colour = density)) +
    geom_segment(data = point_df, 
               aes(x = long, xend = long + coordinateUncertaintyInMeters, 
                   y = lat, yend = lat),
               linewidth = 1.5, colour = "green") +
    geom_text(aes(y = 183915, x = 64050, label = "100 m"), colour = "black",
              size = 5) +
    geom_point(data = point_df, aes(x = long, y = lat), color = "firebrick") +
    stat_ellipse(level = 0.975, linewidth = 1.5, color = "firebrick") +
    coord_fixed() +
    labs(x = "longitude", y = "latitude") +
    theme(legend.position = "")
    

ggMarginal(scatter_norm, type = "histogram")
```

Setting the parameter `p` to 0.95 would implicate that we only sample random points within the boundaries of the uncertainty circle according to a random distribution. The points outside these bounds in the graph above are just shown for explanatory purposes.

```{r}
dat_norm %>%
  mutate(dist = sqrt((point_df$long - long)^2 + (point_df$lat - lat)^2)) %>%
  filter(dist <= 100) %>%
  ggplot(aes(x = long, y = lat)) + 
    geom_point(aes(colour = density)) +
    geom_segment(data = point_df, 
               aes(x = long, xend = long + coordinateUncertaintyInMeters, 
                   y = lat, yend = lat),
               linewidth = 1.5, colour = "green") +
    geom_text(aes(y = 183915, x = 64050, label = "100 m"), colour = "black",
              size = 6) +
    geom_point(data = point_df, aes(x = long, y = lat), color = "firebrick") +
    coord_fixed() +
    labs(x = "longitude", y = "latitude") +
    theme(legend.position = "")
```


# References
